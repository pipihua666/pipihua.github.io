{"componentChunkName":"component---src-templates-blog-post-js","path":"/k8s-persistence/","result":{"data":{"site":{"siteMetadata":{"title":"皮皮花的博客"}},"markdownRemark":{"id":"dcffec73-947d-52ca-baaa-443144609f0f","excerpt":"需求陈述 技术栈：react，docker，k8s \n需求：前端实现界面的 licence 控制，根据 licence 显示不同的背景和文字信息，并且不用重新编译前端镜像，达到可以在宿主机上随时都可以定制的需求 \n需求分析：创建一个 oem 文件夹，存放不同的 licence 的 index.json…","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a8a1e63f4096f24083f3fc17f70493a2/8608d/volumes.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.32911392405063%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEBf/EABUBAQEAAAAAAAAAAAAAAAAAAAID/9oADAMBAAIQAxAAAAGpOsms1lwV/8QAGxAAAgEFAAAAAAAAAAAAAAAAAAECAxARExT/2gAIAQEAAQUCnQUFrRzEzFv/xAAWEQEBAQAAAAAAAAAAAAAAAAABABL/2gAIAQMBAT8BSyX/xAAXEQADAQAAAAAAAAAAAAAAAAAAAQIT/9oACAECAQE/AVbNKP/EABoQAAICAwAAAAAAAAAAAAAAAAABESEgMqH/2gAIAQEABj8CmRW7NuYf/8QAGxABAAICAwAAAAAAAAAAAAAAAQARECExQVH/2gAIAQEAAT8h31euJtgVgBC4DzH/2gAMAwEAAgADAAAAEMjP/8QAFxEBAQEBAAAAAAAAAAAAAAAAAQAhYf/aAAgBAwEBPxARy4X/xAAYEQACAwAAAAAAAAAAAAAAAAAAAREhYf/aAAgBAgEBPxCHbND/xAAaEAACAwEBAAAAAAAAAAAAAAABEQAhMRCR/9oACAEBAAE/EAAmzSkoMAOCmVEgB6rEUJ2YScb5z//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"volumes\"\n        title=\"volumes\"\n        src=\"/static/a8a1e63f4096f24083f3fc17f70493a2/828fb/volumes.jpg\"\n        srcset=\"/static/a8a1e63f4096f24083f3fc17f70493a2/ff44c/volumes.jpg 158w,\n/static/a8a1e63f4096f24083f3fc17f70493a2/a6688/volumes.jpg 315w,\n/static/a8a1e63f4096f24083f3fc17f70493a2/828fb/volumes.jpg 630w,\n/static/a8a1e63f4096f24083f3fc17f70493a2/8608d/volumes.jpg 638w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h4>需求陈述</h4>\n<blockquote>\n<p>技术栈：react，docker，k8s<br /> <br />\n需求：前端实现界面的 licence 控制，根据 licence 显示不同的背景和文字信息，并且不用重新编译前端镜像，达到可以在宿主机上随时都可以定制的需求<br /> <br />\n需求分析：创建一个 oem 文件夹，存放不同的 licence 的 index.json 和图片，前端通过 ajax 可以直接请求本地的文件（这里是 index.json） k8s 在宿主机上持久化本地存储的方式来进行需求开发再合适不过。）<br /></p>\n</blockquote>\n<p>目前官方支持的 3 种本地存储方案如下：</p>\n<h5>emptyDir：</h5>\n<ol>\n<li>pod 在节点上运行时初始化的空卷，pod 中的所有容器都可以访问到该卷。</li>\n<li>pod 从节点上删除时，该卷也会被删除(注意：容器奔溃不会导致 pod 从节点上删除，因此容器奔溃时 emptyDir 是安全的）。</li>\n</ol>\n<p>pod 示例：</p>\n<div class=\"gatsby-highlight\" data-language=\"k8s\"><pre class=\"language-k8s\"><code class=\"language-k8s\">apiVersion: v1\nkind: Pod\nmetadata:\n  name: my-pod\nspec:\n  containers:\n  - image: my-app-image\n    name: my-app\n    volumeMounts:\n    - mountPath: /cache   // pod中的emptyDir路径\n      name: cache-volume\n  volumes:\n    - name: cache-volume\n      emptyDir: {}</code></pre></div>\n<h4>hostPath（适合我的需求）</h4>\n<ol>\n<li>pod 中的文件夹与宿主机上的文件夹相互映射，如果宿主机没有则到 pod 映射，如果 pod 没有则到宿主机映射，如果都没有则默认空文件夹</li>\n<li>宿主机上映射的文件夹的修改会自动同步到 pod 中。</li>\n<li>pod 即使从节点上被删除了（比如：pod 重启），该卷还是会持久化在宿主机上。</li>\n</ol>\n<p>pod 示例：</p>\n<div class=\"gatsby-highlight\" data-language=\"k8s\"><pre class=\"language-k8s\"><code class=\"language-k8s\">apiVersion: v1\nkind: Pod\nmetadata:\n name: my-pod\nspec:\n containers:\n  - name: my-app-image\n    image: my-app-image\n    volumeMounts:\n      - mountPath: /opt/nginx/oem  // pod路径\n        name: oem   // 映射宿主机的volume名称\n volumes:\n  - name: oem\n    hostPath:\n      path: /data/oem    // 宿主机路径</code></pre></div>\n<p>但是还有一点问题，就是 pod 每次重启了，会重新创建 pod 中的 oem 文件夹，这里就是/opt/nginx/oem,那么宿主机上的文件夹/data/oem 也会随着 pod 的重启而替换，所以这需要在 pod 重启的容器中添加一个 command 指令<br /></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">···\nspec:\n containers:\n  - name: my-app-image\n    image: my-app-image\n    command: [&quot;sh&quot;,&quot;-c&quot;,&quot;cp -r -n /opt/assets/public/oem /opt/nginx/ &amp;&amp; nginx -g &#39;daemon off;&#39;&quot;]\n    volumeMounts:\n      - mountPath: /opt/nginx/oem\n        name: oem\n···</code></pre></div>\n<ol>\n<li>/opt/assets/public/oem 是容器中的模版文件夹</li>\n<li><code class=\"language-text\">cp -r -n</code> 如果 pod 中存在/opt/nginx/oem 就不复制（保证每次重启 pod 都是用的宿主机上的 oem 文件夹），也就是初始化 pod 的时候会创建该文件夹</li>\n<li>镜像的 cp 命令升级：\n<code class=\"language-text\">RUN sed -i &#39;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#39; /etc/apk/repositories \\ &amp;&amp; apk add --no-cache coreutils</code>\n（如果 nginx:1.17-alpine 的版本太老，没办法 cp -n）</li>\n<li>至此，需求完成。</li>\n</ol>\n<h4>Local Persistent Volume</h4>\n<p>指的就是利用机器上的磁盘来存放业务需要持久化的数据，和远端存储类似，此时数据依然独立于 Pod 的生命周期，即使业务 Pod 被删除，数据也不会丢失。</p>\n<p>想要更深入的理解 k8s 本地持久化推荐阅读：<a href=\"https://segmentfault.com/a/1190000022860937\">Kubernetes 本地持久化方案</a></p>","frontmatter":{"title":"k8s持久化存储实现前端oem需求","date":"February 21, 2021","description":"前端根据licence显示不同的背景图和文字信息"}},"previous":{"fields":{"slug":"/gatsby/"},"frontmatter":{"title":"Gatsby配置antd"}},"next":null},"pageContext":{"id":"dcffec73-947d-52ca-baaa-443144609f0f","previousPostId":"c4f3b033-6b91-5bd9-9f65-be5cd72f35b4","nextPostId":null}},"staticQueryHashes":["2841359383","3122794013"]}