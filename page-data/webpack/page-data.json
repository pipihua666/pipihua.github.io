{"componentChunkName":"component---src-templates-blog-post-js","path":"/webpack/","result":{"data":{"site":{"siteMetadata":{"title":"皮皮花的博客"}},"markdownRemark":{"id":"c7f2b814-523c-524a-b51b-023e40cb6ba7","excerpt":"1.webpack 中，， 和  的区别是什么？ 1604373359405.jpg看这个图就很明白了： 对于一份同逻辑的代码，当我们手写下一个一个的文件，它们无论是 ESM 还是 commonJS 或是 AMD，他们都是 module ； 当我们写的 module 源文件传到 webpack…","html":"<p><a name=\"fPK71\"></a></p>\n<h4>1.webpack 中，<code class=\"language-text\">module</code>，<code class=\"language-text\">chunk</code> 和 <code class=\"language-text\">bundle</code> 的区别是什么？</h4>\n<p><br /><img src=\"https://cdn.nlark.com/yuque/0/2020/jpeg/1683395/1604373377394-bbca646b-517a-4f66-8086-458c666e7468.jpeg#align=left&#x26;display=inline&#x26;height=372&#x26;margin=%5Bobject%20Object%5D&#x26;name=1604373359405.jpg&#x26;originHeight=372&#x26;originWidth=657&#x26;size=48412&#x26;status=done&#x26;style=none&#x26;width=657\" alt=\"1604373359405.jpg\"><br />看这个图就很明白了：<br /></p>\n<ol>\n<li>对于一份同逻辑的代码，当我们手写下一个一个的文件，它们无论是 ESM 还是 commonJS 或是 AMD，他们都是 module ；</li>\n<li>当我们写的 module 源文件传到 webpack 进行打包时，webpack 会根据文件引用关系生成 chunk 文件，webpack 会对这个 chunk 文件进行一些操作；</li>\n<li>webpack 处理好 chunk 文件后，最后会输出 bundle 文件，这个 bundle 文件包含了经过加载和编译的最终源文件，所以它可以直接在浏览器中运行。</li>\n</ol>\n<p><br />一般来说一个 chunk 对应一个 bundle，比如上图中的 utils.js -> chunks 1 -> utils.bundle.js；但也有例外，比如说上图中，我就用 MiniCssExtractPlugin 从 chunks 0 中抽离出了 index.bundle.css 文件。<br /><code class=\"language-text\">module</code>，<code class=\"language-text\">chunk</code> 和 <code class=\"language-text\">bundle</code> 其实就是同一份逻辑代码在不同转换场景下的取了三个名字：<br />我们直接写出来的是 module，webpack 处理时是 chunk，最后生成浏览器可以直接运行的 bundle。<br />\n<br /></p>\n<p><a name=\"wcxyI\"></a></p>\n<h4>2.<code class=\"language-text\">filename</code> 和 <code class=\"language-text\">chunkFilename</code> 的区别</h4>\n<p><br /><code class=\"language-text\">filename</code> 指<strong>列在</strong> <code class=\"language-text\">entry</code> 中，打包后输出的文件的名称。<br /><code class=\"language-text\">chunkFilename</code> 指<strong>未列在</strong> <code class=\"language-text\">entry</code> 中，却又需要被打包出来的文件（如懒加载的文件）的名称。<br /></p>\n<p><a name=\"jwkVB\"></a></p>\n<h4>3.<code class=\"language-text\">webpackPrefetch</code>、<code class=\"language-text\">webpackPreload</code> 和 <code class=\"language-text\">webpackChunkName</code> 到底是干什么的？</h4>\n<p><br /><code class=\"language-text\">webpackChunkName</code> 是为预加载的文件取别名，<code class=\"language-text\">webpackPrefetch</code> 会在浏览器闲置下载文件，<code class=\"language-text\">webpackPreload</code> 会在父 chunk 加载时并行下载文件。<br />\n<br /><code class=\"language-text\">webpackChunkName</code>打包出来的 bundle 会有 vendors~这种前缀<br />原因是其实 webpack 懒加载是用内置的一个插件 <strong>SplitChunksPlugin</strong> 实现的，这个插件里面有些<strong>默认配置项</strong>，比如说 <code class=\"language-text\">automaticNameDelimiter</code>，默认的分割符就是 <code class=\"language-text\">~</code><br />\n<br /></p>\n<p><a name=\"5rfUT\"></a></p>\n<h4>4.<code class=\"language-text\">hash</code>、<code class=\"language-text\">chunkhash</code>、<code class=\"language-text\">contenthash</code> 有什么不同？</h4>\n<p><br />hash 计算与整个项目的构建相关；<br />chunkhash 计算与同一 chunk 内容相关；<br />contenthash 计算与文件内容本身相关。<br /></p>\n<p><a name=\"zQZjK\"></a></p>\n<h4>5.<code class=\"language-text\">sourse-map</code> 中 <code class=\"language-text\">eval</code>、<code class=\"language-text\">cheap</code>、<code class=\"language-text\">inline</code> 和 <code class=\"language-text\">module</code> 各是什么意思？</h4>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">参数解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">eval</td>\n<td align=\"left\">打包后的模块都使用 <code class=\"language-text\">eval()</code>执行，行映射可能不准；不产生独立的 map 文件，速度很快(不需要复杂转换和打包)，不能映射到原始代码（没有从 loader 中获取 source map）</td>\n</tr>\n<tr>\n<td align=\"left\">cheap</td>\n<td align=\"left\">map 映射只显示行不显示列（只看得到哪行错了），忽略源自 loader 的 source map,即没有源码的映射</td>\n</tr>\n<tr>\n<td align=\"left\">inline</td>\n<td align=\"left\">映射文件以 base64 格式编码，加在 bundle 文件最后，不产生独立的 map 文件</td>\n</tr>\n<tr>\n<td align=\"left\">module</td>\n<td align=\"left\">增加对 loader source map 和第三方模块的映射，即源码的映射</td>\n</tr>\n<tr>\n<td align=\"left\"><code class=\"language-text\">hidden</code><br /><code class=\"language-text\">nosources-source-map</code></td>\n<td align=\"left\">和<code class=\"language-text\">source-map</code>基本相同，但是不会有<code class=\"language-text\">sourceMappingURL</code>注释，这样你就无法定位到源文件，这样你在开发环境能看到具体的目录结构，基本上就是生产环境能用，开发环境不能用，</td>\n</tr>\n</tbody>\n</table>\n<br />\n<br />[原文链接](https://mp.weixin.qq.com/s/H5KeOIKoJ1r3K8-EbKmdLA)<br />","frontmatter":{"title":"webpack中五个容易混淆的知识点","date":"February 20, 2021","description":"webpack中五个容易混淆的知识点"}},"previous":{"fields":{"slug":"/wireshark/"},"frontmatter":{"title":"wireshark过滤器表达式"}},"next":{"fields":{"slug":"/throttle/"},"frontmatter":{"title":"深入浅出防抖和节流"}}},"pageContext":{"id":"c7f2b814-523c-524a-b51b-023e40cb6ba7","previousPostId":"04d86673-ef44-5a8b-93a3-09520a295092","nextPostId":"bf57356d-4b84-586c-a07a-ce55e3140e33"}},"staticQueryHashes":["2841359383","3122794013"]}