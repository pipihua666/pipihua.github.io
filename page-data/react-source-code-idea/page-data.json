{"componentChunkName":"component---theme-src-templates-post-tsx","path":"/react-source-code-idea","result":{"data":{"post":{"id":"62a80c54-54a2-52b6-b790-20cf8943bddb","headings":[{"depth":2},{"depth":3},{"depth":3},{"depth":2},{"depth":3},{"depth":3},{"depth":2},{"depth":3},{"depth":3},{"depth":3},{"depth":3},{"depth":3},{"depth":2}],"frontmatter":{"title":"React源码自顶向下-理论基础篇","path":"/react-source-code-idea","tags":["React"],"excerpt":"React源码自顶向下-理论基础篇","created":"2022-01-18 22:00","createdPretty":"18 January, 2022","updated":"2022-10-29 23:42","updatedPretty":"29 October, 2022","featuredImage":{"childImageSharp":{"sizes":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBP/EABUBAQEAAAAAAAAAAAAAAAAAAAAC/9oADAMBAAIQAxAAAAHA6tMwKB//xAAbEAACAgMBAAAAAAAAAAAAAAABAgARAxIhQf/aAAgBAQABBQJRx8dDWKbHlT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAWEAADAAAAAAAAAAAAAAAAAAAAASD/2gAIAQEABj8CFP8A/8QAGRAAAwADAAAAAAAAAAAAAAAAAAERITFR/9oACAEBAAE/IUtpKIbuWPLRZpxwh7VP/9oADAMBAAIAAwAAABBAD//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAEDAQE/EEf/xAAWEQEBAQAAAAAAAAAAAAAAAAABABH/2gAIAQIBAT8QXLW//8QAGxABAAMAAwEAAAAAAAAAAAAAAQARITFBcVH/2gAIAQEAAT8QQKOSPXkraVbqAIBkT6RWZko2tBmw5Uvan//Z","aspectRatio":1.5037593984962405,"src":"/static/3f8d65654544b2a868dc4abb2dfae41c/f2cbb/header.jpg","srcSet":"/static/3f8d65654544b2a868dc4abb2dfae41c/8850c/header.jpg 200w,\n/static/3f8d65654544b2a868dc4abb2dfae41c/da113/header.jpg 400w,\n/static/3f8d65654544b2a868dc4abb2dfae41c/f2cbb/header.jpg 800w,\n/static/3f8d65654544b2a868dc4abb2dfae41c/c26c2/header.jpg 1200w,\n/static/3f8d65654544b2a868dc4abb2dfae41c/9352a/header.jpg 1600w,\n/static/3f8d65654544b2a868dc4abb2dfae41c/4fb49/header.jpg 1920w","sizes":"(max-width: 800px) 100vw, 800px"}}}},"html":"<h2 id=\"react-设计理念\" style=\"position:relative;\"><a href=\"#react-%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5\" aria-label=\"react 设计理念 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React 设计理念</h2>\n<ul>\n<li>设计理念：快速响应</li>\n<li>制约瓶颈：计算能力和网络延迟也就是 CPU 和 IO</li>\n<li>解决方法：异步可中断更新和人机交互</li>\n</ul>\n<p>主流浏览器的渲染是 60hz,也就是 1000ms/60hz = 16.6ms 浏览器刷新一次。在此过程中，浏览器要进行 JS 的执行 -> 样式布局 -> 样式绘制，如果在这一帧中这三个过程不能全部完成，就要出现掉帧的情况。</p>\n<h3 id=\"如何优化-cpu\" style=\"position:relative;\"><a href=\"#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-cpu\" aria-label=\"如何优化 cpu permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>如何优化 CPU?</h3>\n<p>异步可中断更新：浏览器将一帧的一部分时间预留给 react，react 利用这部分时间来完成自己的工作，如果每个长任务超过了预留时间，react 会中断自己的工作，并将控制权交还给浏览器，等待下一帧到来 react 才继续之前被中断的工作。这样，浏览器在每一帧都有时间进行样式布局和样式绘制，这样就有效减少了掉帧的可能性。</p>\n<h3 id=\"如何优化-io？\" style=\"position:relative;\"><a href=\"#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-io%EF%BC%9F\" aria-label=\"如何优化 io？ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>如何优化 IO？</h3>\n<p>将人机 交互研究的结果整合到真实 UI 中\n<a href=\"https://zh-hans.reactjs.org/docs/concurrent-mode-intro.html\">Concurrent 模式介绍</a></p>\n<h2 id=\"react-架构演进史\" style=\"position:relative;\"><a href=\"#react-%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E5%8F%B2\" aria-label=\"react 架构演进史 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React 架构演进史</h2>\n<h3 id=\"react15\" style=\"position:relative;\"><a href=\"#react15\" aria-label=\"react15 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React15</h3>\n<ol>\n<li>Reconciler 协调器(采用递归的方式执行,也叫 Stack Reconciler)：通过 reconcile（diff 算法）决定哪些组件需要更新</li>\n<li>\n<p>Renderer 渲染器：将需要更新的组件渲染到真实 DOM 上，这里有以下渲染器：</p>\n<ul>\n<li>ReactDOM：渲染到浏览器，或者 SSR</li>\n<li>ReactNative：渲染 App 原生组件</li>\n<li>ReactTest：将组件渲染 成纯 JS 对象，一般用于测试</li>\n<li>ReactArt：将组件渲染到 Canvas 或者 SVG 上</li>\n</ul>\n</li>\n</ol>\n<p>React15 更新流程 是协调器和渲染器依次执行工作的，本来先更新的组件要比后更新的组件先变化，但由于整个过程都是同步的，所以看不出变化。</p>\n<p>但是如果把同步更新变为异步可中断的更新，那中断之后，对于需要批量更新的组件，后更新的组件不会渲染到视图上，而先更新的组件已经渲染到了视图上，感觉就像一个 bug。</p>\n<h3 id=\"react16\" style=\"position:relative;\"><a href=\"#react16\" aria-label=\"react16 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React16</h3>\n<ol>\n<li>新增 Scheduler 调度器：决定高优先的任务先进入协调器。</li>\n<li>Reconciler 协调器(基于 Fiber 节点实现，也叫 Fiber Reconciler)：通过 reconcile（diff 算法）创建虚拟 DOM 树，给需要更新的组件打上<code class=\"language-text\">Update</code>标记，决定哪些组件需要<code class=\"language-text\">批量</code>更新</li>\n<li>Renderer 渲染器：接收到通知，将被打了<code class=\"language-text\">Update</code>标记的组件，也就是将需要更新的组件渲染到真实 DOM 上</li>\n</ol>\n<p>React16 的流程是 如果协调器中有任务正在 diff，但是调度器有更高优的任务进来，那刚才的任务就会中断执行，反而先执行高优的任务。</p>\n<p>由于调度器和协调器都是在内存中工作的，所以即使有中断发生，用户也不会看到更新不完全的视图。</p>\n<h2 id=\"react-新架构-fiber\" style=\"position:relative;\"><a href=\"#react-%E6%96%B0%E6%9E%B6%E6%9E%84-fiber\" aria-label=\"react 新架构 fiber permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React 新架构-Fiber</h2>\n<h3 id=\"代数效应\" style=\"position:relative;\"><a href=\"#%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94\" aria-label=\"代数效应 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>代数效应</h3>\n<ul>\n<li><code class=\"language-text\">代数效应</code>是函数式编程中的概念，用于将<code class=\"language-text\">副作用</code>从函数调用中分离。</li>\n<li>react 通过<code class=\"language-text\">代数效应</code>来实现异步可中断的更新。</li>\n</ul>\n<h3 id=\"什么是-fiber\" style=\"position:relative;\"><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-fiber\" aria-label=\"什么是 fiber permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>什么是 Fiber</h3>\n<ul>\n<li>Fiber 纤程</li>\n<li>Process 进程</li>\n<li>Thread 线程</li>\n<li>Coroutine 协程</li>\n</ul>\n<p>JS 已通过 Generator 实现了协程，为什么 React 还要自己实现一个 Fiber 纤程呢？</p>\n<ol>\n<li>Generator 具有传染性，如果一个函数变成了 generator，那么调用它的函数也会变成 generator，从而受到了影响。</li>\n<li>\n<p>最重要的一点是：Fiber 架构为了达到两个目的：</p>\n<ol>\n<li>异步可中断并且继续</li>\n<li>更新具有优先级，高优先级的更新可以打断低优先级的更新。generator 可以实现第一点，但是无法实现第二点。</li>\n</ol>\n</li>\n</ol>\n<p><a href=\"https://github.com/facebook/react/issues/7942\">官方 issue 解释</a></p>\n<h3 id=\"fiber-架构的原理\" style=\"position:relative;\"><a href=\"#fiber-%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8E%9F%E7%90%86\" aria-label=\"fiber 架构的原理 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Fiber 架构的原理</h3>\n<ol>\n<li>作为架构来说，之前 React15 的 Reconciler 采用递归的方式执行，数据保存在递归调用栈中，所以被称为 stack Reconciler。React16 的 Reconciler 基于 Fiber 节点实现，被称为 Fiber Reconciler。</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">App</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>value<span class=\"token punctuation\">,</span> setValue<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>div\n      onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">></span>\n      pipihua<span class=\"token operator\">-</span><span class=\"token punctuation\">{</span>value<span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\nReact<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>App <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"root\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 376px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/dcd9809ef2af2ece16c8174330764296/d38a6/fiber.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 146.66666666666669%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAdCAYAAACqhkzFAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEqklEQVRIx5VWWUgkVxR9vZsebbUdWzPTM9PB1ijxwy+RJEMQx59Ikg8xw4SYqEh+TKIQJZAMJOiH/kiicUERd3FFXAIiiv644YKIu8Z9aZd2bxd6sXJuUd3TDMNM++Dwyq5Xp27dc++5ssrKSgZ47u/vL5tMJu7i4sKK/RawnJ+fc8vLyz/29/ez2NhYJWPsAfAI0AEa4D32+qLDvb29GhDtbW1tcevr67e0r6ysWI+Ojrjt7e0/cMxfo9GEYg8HIoCvgM+Ah4Ae8HUQNjc3s7KyMi+j0fjf1dUVh8jMAEVpxksowp85jmNRUVHuOC4RIAcUgBiQCb+9WhkZGWxsbCygpaXl6cTERNje3t5H+fn5z+rq6p6CzC06OprdZakkEslj4W1sdnaWlZaW0qWIIqNciUQinZA78TvZPDw8KGSF8LAP7cK1TNjFXl5eSkEAkROc16vf4uLiWEdHhxzJL1xbWxs8PT3tQP7akdN/DQZDL3IYjRy7/r3d3d2sqalJA0GObDYbt7OzQ8pyIOZub285kP5GkWq12gAc/wAIclKWSud9IR1PAHfW0NDAampq7iOqMzzIUe2dnZ1xZrOZ/uQ2NzdfEmFoaCg97CeQqClbPAE0EMjVvOL0OSkpKbLV1dWfgL8ODg6yUC5/Tk5OFszMzPwzPz8fNjQ0dCeVWWBgILOL8TpycnLYXZcPtVRjYyNdy61WK+vq6rIrTeuhXC5XK5VKlwlFMplMOj09/Qxd8ws+88XGxsbXIyMj342Pj3/f1tamcyqld6/CwkKGDlFDjAMSgcSgFiSFLRYLh77+Ff3NsEtdIuzs7GSIQnN5eWkkQuwcWo+zL5TQy8PDQwaxXCMsLi5mVVVV9/BAN6JcQ/nMXV9fz8Fplo+Pj3eg/IulpSWGNEhcIgQZn8fg4GB5RETEg/j4eI+CggK3kJAQXVhYmD/lztvbW3wXlcVSqVQnWJK0urqaJSQk0O9SIsM9f/JDGIhrbFCSDQ8Ps5KSEklQUJA+LS1NOTAwIINlqeHSqtHRUf6cy4RFRUUM3ucOIYaQ/Ev0sAGdYsC+ixyaYBjxfX19VDYil1Vub28nlfmyubm54U5OThwqDw4O/k3nIiMjPYXetePeGwnr6+tZbW2tGtEYqO6gMI0BvgaJHIb7O+UyOztb7jQCSCTPt0a6sLDwKaL5ZnFx8UuU0Oetra2J+NRvQX6/vLz8TZ3i/jY+if0B1CITcuZAeHi4ODExken1eoYqoNEg8vX19VSpVH4oKd7l6T5GMbxfoaDS8BE8TTE1NcWSkpL4siHPwzwh83QjlWNiYsjd+UkpTD1Kg5hqOTMzk+Xm5jKGjmDUqz09PT7JycmfwHV0KCMtbn6IYRWANEjT09Md0cLd/XD2SVZWVgjuaeGVWoj6GJ4qycvLY6yiooJMVoUZMoF8XZHaMAcjcIDyucFM+QFC8WT4p8Af57Yg1jHOGqn/ce4Q1ya41RcwEEfZ+NrLZnd3l0P/OkYAxMoS8qtITU39mEYELRDz88e+8OIEMhG+l6GiNxmDYF9WwAb7MsNsyb7ShHxp8amPEPU1ncM9G0rLhksLnZubm3uO5mD/A/TGXVvpoU8wAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"fiber节点的联系\"\n        title=\"fiber节点的联系\"\n        src=\"/static/dcd9809ef2af2ece16c8174330764296/d38a6/fiber.png\"\n        srcset=\"/static/dcd9809ef2af2ece16c8174330764296/5a46d/fiber.png 300w,\n/static/dcd9809ef2af2ece16c8174330764296/d38a6/fiber.png 376w\"\n        sizes=\"(max-width: 376px) 100vw, 376px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ol start=\"2\">\n<li>作为静态数据结构来说，每个 Fiber 节点对应了一个组件 React Element，保存了组件的相关信息，比如该组件的类型、对应的 Dom 节点等信息，这时的 Fiber 节点也就是我们所说的虚拟 Dom。</li>\n<li>作为动态工作单元来说，每个 Fiber 节点保存了本次更新相关的信息</li>\n</ol>\n<h3 id=\"fiber-的工作原理\" style=\"position:relative;\"><a href=\"#fiber-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\" aria-label=\"fiber 的工作原理 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Fiber 的工作原理</h3>\n<ul>\n<li>采用双缓存的工作机制\nFiber 通过当前屏幕上显示内容对应的 Fiber 树称为 <code class=\"language-text\">current Fiber</code> 树和正在内存中构建的 Fiber 树称为 <code class=\"language-text\">workInProgress Fiber</code> 树实现双缓存。通过直接在内存中绘制<code class=\"language-text\">workInProgress Fiber</code> 树,绘制完毕后直接替换<code class=\"language-text\">current Fiber</code> 树来实现页面的 dom 的更新。</li>\n</ul>\n<h3 id=\"总结\" style=\"position:relative;\"><a href=\"#%E6%80%BB%E7%BB%93\" aria-label=\"总结 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>总结</h3>\n<ol>\n<li>\n<p>如何做到快速响应</p>\n<p>异步可中断更新和 concurrent 模式</p>\n</li>\n<li>\n<p>为什么异步可中断更新可以实现快速响应</p>\n<p>当渲染大量 dom 节点这种 CPU 密集型操作时，同步更新会导致掉帧效果，而异步可中断更新不会</p>\n</li>\n<li>\n<p>为什么同步更新在 CPU 密集时会导致掉帧</p>\n<p>当同步的 js 计算时间过长产生长任务时，浏览器就没时间去做样式绘制和布局了</p>\n</li>\n<li>\n<p>怎样实现异步可中断更新</p>\n<p>Reconciler 协调器 实现了 Fiber ，Fiber 可实现异步可中断的更新</p>\n</li>\n<li>\n<p>为什么要有 React Fiber</p>\n<p>Generator 协程可实现中断后恢复，但是不能实现任务优先级调度。所以 React 内部实现的一套状态更新机制。Fiber 支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。</p>\n</li>\n<li>\n<p>Fiber 是如何实现异步可中断更新</p>\n<p>不晓得，这可能就是代数效应吧，我们不知道实现，但是知道它可。待源码查询一下 // TODO:</p>\n</li>\n<li>\n<p>为什么 react 15 不能实现异步可中断更新</p>\n<p>在 React15 及以前，Reconciler 采用递归的方式创建虚拟 DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。</p>\n</li>\n</ol>\n<h2 id=\"参考\" style=\"position:relative;\"><a href=\"#%E5%8F%82%E8%80%83\" aria-label=\"参考 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>参考</h2>\n<ul>\n<li><a href=\"https://react.iamkasong.com/state/reactdom.html#%E5%88%9B%E5%BB%BAfiber\">React 源码解析</a></li>\n</ul>"},"primaryTag":{"name":"React","color":"#5e8cb4"}},"pageContext":{"postId":"62a80c54-54a2-52b6-b790-20cf8943bddb","primaryTag":"React"}},"staticQueryHashes":["1116962356","2275848304","3097946992","3138592700","3462520645"]}