{"componentChunkName":"component---theme-src-templates-post-tsx","path":"/garbage-collection","result":{"data":{"post":{"id":"e574fc66-1ba1-5d18-a721-f0aa774f2de2","headings":[{"depth":2},{"depth":2},{"depth":2},{"depth":3},{"depth":3},{"depth":3},{"depth":2},{"depth":3},{"depth":2},{"depth":2},{"depth":2}],"frontmatter":{"title":"V8的垃圾回收机制和内存限制","path":"/garbage-collection","tags":["JavaScript"],"excerpt":"V8的垃圾回收机制，新生代Scavenge算法，老生代Mark-Sweep & Mark-Compact","created":"2021-08-08 16:33","createdPretty":"08 August, 2021","updated":"2021-08-08 16:33","updatedPretty":"08 August, 2021","featuredImage":{"childImageSharp":{"sizes":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAUBAwT/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAv/aAAwDAQACEAMQAAAB0QqsiWAqD//EABwQAAEEAwEAAAAAAAAAAAAAAAEAAhEUBBIhMf/aAAgBAQABBQK2YtlHMW3GiU73/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQIBAT8Bqv/EABcQAQEBAQAAAAAAAAAAAAAAAAAyEDH/2gAIAQEABj8ClCd6/8QAGxABAAMAAwEAAAAAAAAAAAAAAQARIUFRgZH/2gAIAQEAAT8hdVfsH6exB0SzqmAJbkn/2gAMAwEAAgADAAAAEGQ//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQIBAT8QtT//xAAdEAEAAgEFAQAAAAAAAAAAAAABABExIUFRYeHw/9oACAEBAAE/EKUW8HmJF6nzaVO12+QHMTcjARDNC5jNQdOZ/9k=","aspectRatio":1.680672268907563,"src":"/static/a5e3de6178f36e96f4396812c635df6c/f2cbb/header.jpg","srcSet":"/static/a5e3de6178f36e96f4396812c635df6c/8850c/header.jpg 200w,\n/static/a5e3de6178f36e96f4396812c635df6c/da113/header.jpg 400w,\n/static/a5e3de6178f36e96f4396812c635df6c/f2cbb/header.jpg 800w,\n/static/a5e3de6178f36e96f4396812c635df6c/c26c2/header.jpg 1200w,\n/static/a5e3de6178f36e96f4396812c635df6c/9352a/header.jpg 1600w,\n/static/a5e3de6178f36e96f4396812c635df6c/4fb49/header.jpg 1920w","sizes":"(max-width: 800px) 100vw, 800px"}}}},"html":"<h2 id=\"v8-的内存限制\" style=\"position:relative;\"><a href=\"#v8-%E7%9A%84%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6\" aria-label=\"v8 的内存限制 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>V8 的内存限制</h2>\n<p>在一般的后端开发语言中都是没有内存限制的，由于基于 v8 最初是为浏览器设计的，64 位下的 1.4GB 和 32 位下的 0.7GB 的限制值用起来是绰绰有余的，导致 Nodejs 在开发的过程中只能在该限制下运行，这将会导致 Nodejs 无法直接操作大内存对象，比如无法将一个 2GB 的文件读入内存中进行字符串分析处理，即使物理内存有 32 个 G。</p>\n<h2 id=\"v8-内存限制的原因\" style=\"position:relative;\"><a href=\"#v8-%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6%E7%9A%84%E5%8E%9F%E5%9B%A0\" aria-label=\"v8 内存限制的原因 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>V8 内存限制的原因</h2>\n<ol>\n<li>表面原因是浏览器对 1.4GB 和 0.7GB 的使用绰绰有余</li>\n<li>深层原因是 v8 的垃圾回收机制的限制。按照官方说法，以 1.5GB 的垃圾回收堆内存为例，v8 做一次小的垃圾回收需要 50ms 以上，做一次非增量式的垃圾回收甚至需要 1s 以上。因为 js 的执行是单线程的，在垃圾回收时会暂停 js 的执行，导致应用的性能和响应能力直线下降。（垃圾回收是在特定的时候执行的）</li>\n</ol>\n<p>当然，Nodejs 在启动的时候也可以通过传递参数来调整内存限制的大小，实例如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">node <span class=\"token operator\">--</span>max<span class=\"token operator\">-</span>old<span class=\"token operator\">-</span>space<span class=\"token operator\">-</span>size<span class=\"token operator\">=</span><span class=\"token number\">1700</span> test<span class=\"token punctuation\">.</span>js <span class=\"token comment\">// 老生代内存空间大小。单位为MB</span>\nnode <span class=\"token operator\">--</span>max<span class=\"token operator\">-</span><span class=\"token keyword\">new</span><span class=\"token operator\">-</span>space<span class=\"token operator\">-</span>size<span class=\"token operator\">=</span><span class=\"token number\">1024</span> test<span class=\"token punctuation\">.</span>js <span class=\"token comment\">// 新生代内存空间大小。单位为MB</span></code></pre></div>\n<h2 id=\"v8-的垃圾回收机制\" style=\"position:relative;\"><a href=\"#v8-%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6\" aria-label=\"v8 的垃圾回收机制 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>V8 的垃圾回收机制</h2>\n<h3 id=\"v8-的内存分代\" style=\"position:relative;\"><a href=\"#v8-%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E4%BB%A3\" aria-label=\"v8 的内存分代 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>V8 的内存分代</h3>\n<p>在 v8 中内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f9af4b6ad825e60d24ae99e349c223b5/0c02e/1.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 12.666666666666668%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAADABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3AUH/8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQABBQJ//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQAGPwJ//8QAFhAAAwAAAAAAAAAAAAAAAAAAABBB/9oACAEBAAE/ISr/2gAMAwEAAgADAAAAEHPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxAAAgEFAAAAAAAAAAAAAAAAAAERITFBUZH/2gAIAQEAAT8QV1RDjBCjS4f/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1.jpg\"\n        title=\"1.jpg\"\n        src=\"/static/f9af4b6ad825e60d24ae99e349c223b5/e5166/1.jpg\"\n        srcset=\"/static/f9af4b6ad825e60d24ae99e349c223b5/f93b5/1.jpg 300w,\n/static/f9af4b6ad825e60d24ae99e349c223b5/b4294/1.jpg 600w,\n/static/f9af4b6ad825e60d24ae99e349c223b5/e5166/1.jpg 1200w,\n/static/f9af4b6ad825e60d24ae99e349c223b5/0c02e/1.jpg 1206w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h3 id=\"scavenge（清道夫）算法\" style=\"position:relative;\"><a href=\"#scavenge%EF%BC%88%E6%B8%85%E9%81%93%E5%A4%AB%EF%BC%89%E7%AE%97%E6%B3%95\" aria-label=\"scavenge（清道夫）算法 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Scavenge（清道夫）算法</h3>\n<p>新生代中的对象主要通过 Scavenge 算法进行垃圾回收，它将堆内存一分为二，每一部分空间称为 semispace。在这两个 semispace 空间中，只有一个处于使用状态，另一个处于闲置状态。处于使用状态的 simispace 空间称为 From 空间，处于闲置状态的空间称为 To 空间。当开始从 From 空间进行垃圾回收时，会将存活对象复制到 To 空间中，非存活对象的空间将会被释放。完成复制后 From 空间和 To 空间角色互换。（相当于漏斗一样，无限过滤）</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1098px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/755d326b9602da68ef97791931a259d3/46d48/2.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.666666666666668%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAFABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3KAH/8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQABBQJ//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQAGPwJ//8QAFRABAQAAAAAAAAAAAAAAAAAAABH/2gAIAQEAAT8hVX//2gAMAwEAAgADAAAAEIAP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGhABAAMAAwAAAAAAAAAAAAAAAQARIUFhgf/aAAgBAQABPxBVTXqUTRfZbhSf/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2.jpg\"\n        title=\"2.jpg\"\n        src=\"/static/755d326b9602da68ef97791931a259d3/46d48/2.jpg\"\n        srcset=\"/static/755d326b9602da68ef97791931a259d3/f93b5/2.jpg 300w,\n/static/755d326b9602da68ef97791931a259d3/b4294/2.jpg 600w,\n/static/755d326b9602da68ef97791931a259d3/46d48/2.jpg 1098w\"\n        sizes=\"(max-width: 1098px) 100vw, 1098px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>Scavenge 算法的缺点是只能使用堆内存的一半，是典型的空间换时间的算法，所以无法大规模应用到所有的垃圾回收中。但可以发现，Scavenge 非常适合应用在新生代中，因为新生代中对象的生命周期较短，恰恰适合这个算法。</p>\n<h3 id=\"晋升\" style=\"position:relative;\"><a href=\"#%E6%99%8B%E5%8D%87\" aria-label=\"晋升 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>晋升</h3>\n<p>对象从新生代移动到老生代的过程称为晋升，晋升的条件主要有两个。</p>\n<ol>\n<li>对象是否经历过 Scavenge 回收</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1058px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7e61cd7f0b6665e93451d0e2e239f2f4/3e9cd/3.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 72.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdylQhh//8QAFhAAAwAAAAAAAAAAAAAAAAAAEBEg/9oACAEBAAEFAg4//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGRAAAgMBAAAAAAAAAAAAAAAAABEBEDFB/9oACAEBAAE/IZTHSdOV/9oADAMBAAIAAwAAABDgD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABwQAAICAgMAAAAAAAAAAAAAAAERACEQMUFRkf/aAAgBAQABPxBjI1uoRHBidQvEFg8f/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"3.jpg\"\n        title=\"3.jpg\"\n        src=\"/static/7e61cd7f0b6665e93451d0e2e239f2f4/3e9cd/3.jpg\"\n        srcset=\"/static/7e61cd7f0b6665e93451d0e2e239f2f4/f93b5/3.jpg 300w,\n/static/7e61cd7f0b6665e93451d0e2e239f2f4/b4294/3.jpg 600w,\n/static/7e61cd7f0b6665e93451d0e2e239f2f4/3e9cd/3.jpg 1058w\"\n        sizes=\"(max-width: 1058px) 100vw, 1058px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>2.To 空间的内存占比是否超过 25%</p>\n<blockquote>\n<p>设置 25%这个限制原因是当这里 Scavenge 算法完成后，这个 To 空间将变成 From 空间接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。</p>\n</blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1058px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f20d021621b998b9150ca3d2b5b71f89/3e9cd/4.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 74%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdylQhh//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQABBQJf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGBAAAwEBAAAAAAAAAAAAAAAAAAEREDH/2gAIAQEAAT8hcpSj7v8A/9oADAMBAAIAAwAAABDgD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABsQAAMAAwEBAAAAAAAAAAAAAAABESFRkUGB/9oACAEBAAE/EKX3BPlfwnTG4FlKkWkf/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"4.jpg\"\n        title=\"4.jpg\"\n        src=\"/static/f20d021621b998b9150ca3d2b5b71f89/3e9cd/4.jpg\"\n        srcset=\"/static/f20d021621b998b9150ca3d2b5b71f89/f93b5/4.jpg 300w,\n/static/f20d021621b998b9150ca3d2b5b71f89/b4294/4.jpg 600w,\n/static/f20d021621b998b9150ca3d2b5b71f89/3e9cd/4.jpg 1058w\"\n        sizes=\"(max-width: 1058px) 100vw, 1058px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h2 id=\"mark-sweep\" style=\"position:relative;\"><a href=\"#mark-sweep\" aria-label=\"mark sweep permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mark-Sweep</h2>\n<p>对于老生代中的对象，由于存活时间较长，再采用 Scavenge 的方式会有两个问题：</p>\n<ol>\n<li>存活对象过多，复制存活对象向的效率将会很低（筛选不掉很多非存活对象，浪费时间）</li>\n<li>浪费一半的内存空间</li>\n</ol>\n<p>Mark-Sweep 是标记清除的意思，它分为标记和清除两个阶段。在标记阶段遍历堆中所有对象，并标记存活的对象，在随后的清除过程中只清除没有标记的对象。\n可以看出，Scavenge 只复制活着的对象，Mark-Sweep 只清除死亡的对象。由于活对象在新生代中占比少，死对象在老生代中的占比少，这就是两种方式各自高效 的原因。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/8a149046a4dd82710cc03d53d0311ecc/801ec/5.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 13.666666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAADABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3AQH/8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQABBQJ//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQAGPwJ//8QAFhAAAwAAAAAAAAAAAAAAAAAAAAEQ/9oACAEBAAE/IYz/2gAMAwEAAgADAAAAEHPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxAAAgIDAQAAAAAAAAAAAAAAABEBQSExUZH/2gAIAQEAAT8Qcut8HLrwlk//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"5.jpg\"\n        title=\"5.jpg\"\n        src=\"/static/8a149046a4dd82710cc03d53d0311ecc/e5166/5.jpg\"\n        srcset=\"/static/8a149046a4dd82710cc03d53d0311ecc/f93b5/5.jpg 300w,\n/static/8a149046a4dd82710cc03d53d0311ecc/b4294/5.jpg 600w,\n/static/8a149046a4dd82710cc03d53d0311ecc/e5166/5.jpg 1200w,\n/static/8a149046a4dd82710cc03d53d0311ecc/801ec/5.jpg 1442w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h3 id=\"缺点\" style=\"position:relative;\"><a href=\"#%E7%BC%BA%E7%82%B9\" aria-label=\"缺点 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>缺点</h3>\n<p>清除后的内存空间会出现不连续的现象，这种不连续的内存称为“内存碎片”。内存碎片会对后续的内存分配造成问题，因为有可能新生代中晋升的对象需要的内存较大，但是老生代中没有可直接分配的内存大小，对于这种需要分配一个大对象的况，这时所有的”碎片空间“都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。</p>\n<h2 id=\"mark-compact\" style=\"position:relative;\"><a href=\"#mark-compact\" aria-label=\"mark compact permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mark-Compact</h2>\n<p>Mark-Compact 是标记整理的意思。它和 Mark-Sweep 的区别是，在标记对象死亡后，在整理的过程中，将或者的对象往一端移动，移动完成后直接清理掉边界外的内存。（也就是清理以下的空洞内存）</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 740px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d42a6818c60ad05b31f58c68be688d3f/07f3a/6.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 25.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAFABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAG2AD//xAAWEAADAAAAAAAAAAAAAAAAAAAAEBH/2gAIAQEAAQUCKv/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAABD/2gAIAQEABj8Cf//EABgQAAMBAQAAAAAAAAAAAAAAAAARYTFR/9oACAEBAAE/IXBOGw//2gAMAwEAAgADAAAAEPPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxABAAICAwAAAAAAAAAAAAAAAQARIXExQcH/2gAIAQEAAT8QSPBz7Gwa6xHuGhP/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"6.jpg\"\n        title=\"6.jpg\"\n        src=\"/static/d42a6818c60ad05b31f58c68be688d3f/07f3a/6.jpg\"\n        srcset=\"/static/d42a6818c60ad05b31f58c68be688d3f/f93b5/6.jpg 300w,\n/static/d42a6818c60ad05b31f58c68be688d3f/b4294/6.jpg 600w,\n/static/d42a6818c60ad05b31f58c68be688d3f/07f3a/6.jpg 740w\"\n        sizes=\"(max-width: 740px) 100vw, 740px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<blockquote>\n<p>v8 主要使用 Mark-Sweep,在空间不足以从新生代中晋升的对象分配时才使用 Mark-Compact</p>\n</blockquote>\n<h2 id=\"增量标记\" style=\"position:relative;\"><a href=\"#%E5%A2%9E%E9%87%8F%E6%A0%87%E8%AE%B0\" aria-label=\"增量标记 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>增量标记</h2>\n<p>在执行三种垃圾回收算法时都需要将 js 主线程的应用逻辑停顿下来，待执行完垃圾回收之后再恢复执行应用逻辑。这种行为称为“全停顿”。对于新生代默认得较小，且其中存活的对象较少，即使全停顿也影响不大。但对于 v8 对老生代的配置较大，而且存活对象较多，“全停顿”造成的后果是非常可怕的，需要设法改善。</p>\n<blockquote>\n<p>增量标记就是拆分为许多小步前进，每做完一步，就让 js 的应用逻辑执行一小会儿。两者互相交替执行。</p>\n</blockquote>\n<p>v8 后续要引进了“延迟清理“，”增量式整理“，”并行标记“，”并行清除“等,进一步地减少垃圾回收对主线程的影响，为应用提升更多的性能。</p>\n<h2 id=\"高效使用内存\" style=\"position:relative;\"><a href=\"#%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98\" aria-label=\"高效使用内存 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>高效使用内存</h2>\n<p>在正常的 js 执行中，无法立即回收的内存有”闭包”和“全局变量”引用这两种情况。由于 v8 的内存限制，要十分小心此类变量是否无限制的添加，因为他会导致老生代中的对象增多。所以建议如下：</p>\n<ol>\n<li>尽可能少的使用全局变量</li>\n<li>手动清除定时器</li>\n<li>少用闭包</li>\n<li>清除 DOM 引用</li>\n<li>弱引用，如 ES6 中的<code class=\"language-text\">WeakMap</code>和<code class=\"language-text\">WeakSet</code>就是为了解决内存泄漏的问题而诞生的</li>\n</ol>"},"primaryTag":{"name":"JavaScript","color":"#1e81b0"}},"pageContext":{"postId":"e574fc66-1ba1-5d18-a721-f0aa774f2de2","primaryTag":"JavaScript"}},"staticQueryHashes":["1116962356","2275848304","3097946992","3138592700","3462520645"]}